#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>
using namespace std;


int main() {
    // Ускоряем ввод/вывод
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;  // Читаем размер последовательности

    vector<double> arr(n);       // Массив логарифмов дробей
    vector<double> prefix(n+1);  // Префиксные суммы логарифмов (prefix[0] = 0)

    // Инициализируем префиксную сумму нулем
    prefix[0] = 0;

    // Читаем и обрабатываем дроби
    for (int i = 0; i < n; i++) {
        int a, b;      // числитель и знаменатель
        char slash;    // символ '/' между ними

        // Читаем дробь в формате "a/b"
        cin >> a >> slash >> b;

        // Преобразуем дробь в вещественное число
        double fraction = (double)a / b;

        // Берем натуральный логарифм от дроби
        // Это ключевой шаг: log(a/b) = log(a) - log(b)
        arr[i] = log(fraction);

        // Считаем префиксную сумму логарифмов
        // prefix[i+1] = сумма логарифмов первых i+1 элементов
        prefix[i+1] = prefix[i] + arr[i];
    }

    // Инициализируем переменные для поиска максимального отрезка
    double max_sum = -1e30;  // Очень маленькое число (минус бесконечность)
    int best_l = 0;          // Левый индекс лучшего отрезка
    int best_r = 0;          // Правый индекс лучшего отрезка

    // Алгоритм Кадане (Kadane's algorithm) для поиска подмассива с максимальной суммой
    double current_sum = 0;  // Текущая сумма на рассматриваемом отрезке
    int current_start = 0;   // Начало текущего отрезка

    for (int i = 0; i < n; i++) {
        // Добавляем текущий элемент к текущей сумме
        current_sum += arr[i];

        // Проверяем, не стал ли текущий отрезок лучше найденного ранее
        if (current_sum > max_sum) {
            // Если текущая сумма больше максимальной, обновляем результат
            max_sum = current_sum;
            best_l = current_start;
            best_r = i;
        }

        // Если текущая сумма стала отрицательной, начинаем новый отрезок
        // (логарифм может быть отрицательным, т.к. дробь < 1 → log < 0)
        if (current_sum < 0) {
            current_sum = 0;          // Сбрасываем сумму
            current_start = i + 1;    // Начинаем новый отрезок со следующего элемента
        }
    }

    // Выводим результат: индексы l и r лучшего отрезка
    cout << best_l << " " << best_r << endl;

    return 0;
}
